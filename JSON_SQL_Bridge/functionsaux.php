<?php
/*
JSON_SQL_Bridge 1.1
Copyright 2016 Frank Vanden berghen
All Right reserved.

JSON_SQL_Bridge is not a free software. The JSON_SQL_Bridge software is NOT licensed under the "Apache License". 
If you are interested in distributing, reselling, modifying, contibuting or in general creating 
any derivative work from JSON_SQL_Bridge, please contact Frank Vanden Berghen at frank@timi.eu.
*/
use kibella\O1z; function l20($O20,$l21=NULL) { if ($l21 === NULL) { echo $O20; } else { assert($l21 !== FALSE,"The file handle is not false"); fputs($l21,$O20); } } function O21($l22,$O22,$l23=array(),$O23=0,&$l24=0) { if (!is_array($l22)) { user_error( __FUNCTION__.": The first argument should be an array",E_USER_ERROR); return; } if (!is_callable($O22)) { if (is_array($O22)) { $O22=$O22[0]."::".$O22[1]; } user_error( __FUNCTION__.": The second argument is not a valid callback ".$O22,E_USER_ERROR); return; } if (!is_null($l23) && !is_array($l23)) { user_error( __FUNCTION__.": The third argument should be an array",E_USER_ERROR); return; } $O24=count($l22); if (is_null($l23)) { $l23=array(); } $l25=array(); $l25[]=NULL; $l25[]=NULL; $l25[]=$O23; $l25[]=&$l24; $l25[]=$O24; $l25[]=$l23; $l21=NULL; if ($O24>0) { $O23=-1; foreach ($l22 as $O25 => $l26) { $O23 ++; $l25[0]=$l26; $l25[1]=$O25; $l25[2]=$O23; if (is_array($l26)) { call_user_func_array($O22,$l25); $l24 ++; $l21=O21($l26,$O22,$l23,$O23,$l24); } else { $l21=call_user_func_array($O22,$l25); } } $l24 --; } else { $l21=call_user_func_array($O22,$l25); $l24 --; } return $l21; } function O26($l22) { $l27=array(); $O27=array_keys($l22); sort($O27); foreach ($O27 as $O25) { $l27[$O25]=$l22[$O25]; } return $l27; } function l28($l22,$O28=FALSE) { return O21($l22,"updateDimension",array("max_number_elements" => $O28)); } function l29($l26,$O25,$O23,$l24,$O24,$O29) { static $l2a; static $O2a; static $l2b; static $O2b; if ($O23 == 0 && $l24 == 0) { $l2a=1; $O2a=array(array("count" => 0)); $l2b=0; $O2b=FALSE; if (array_key_exists("max_number_elements",$O29)) $O2b=$O29["max_number_elements"]; } if ($O24>0) { $O2a[$l24]["count"]++; } if (is_array($l26)) { $O2a[]=array("count" => 0); } else { if ($O2a[$l24]["count"] == $O24) { if ($l24+1>=$l2a) { $l2b=max($l2b,$O2a[$l24]["count"]); } $l2a=max($l2a,$l24+1); array_pop($O2a); } } if ($O2b === FALSE) { return max($l2a,$l24+1); } else { return array(max($l2a,$l24+1),$l2b); } } function l2c($O2c,$l2d=0744,$O2d=TRUE,$l2e=FALSE,$O2e="") { $l2f=TRUE; if (!is_dir($O2c)) { if ($l2e) O2f("",O5,$O2e); $l2f=mkdir($O2c,$l2d,$O2d); } return $l2f; } function l2g($O2g) { if (strlen($O2g)>0) { $O2g=preg_replace("/\\s*,\\s*/",",",$O2g); $l2h=explode(",",strtolower($O2g)); for ($O2h=0; $O2h<count($l2h); $O2h ++) { $l2h[$O2h]=preg_replace("/(^\"(.*)\"\$)|(^\\'(.*)\\'\$)/","\$2\$4",$l2h[$O2h]); } } else { $l2h=array(); } return $l2h; } function l2i($O2c,$O2i=FALSE,$l2j=0) { if (!is_dir($O2c)) { echo "<pre>ERROR: $O2c must be a directory\nThe deletion process failed.\n</pre>"; return FALSE; } if (substr($O2c,strlen($O2c)-1,1) != "/") { $O2c.="/"; } $O2j=glob($O2c."*",l2k); foreach ($O2j as $O2k) { if (is_dir($O2k)) { l2i($O2k); } else { if ($l2j == 0 || $l2j<0 && (time()-filemtime($O2k))>abs($l2j) || $l2j>0 && filemtime($O2k)<$l2j) { unlink($O2k); } } } if (!$O2i) rmdir($O2c); return TRUE; } function l2l($O20,$O2l=FALSE) { if ($O2l) { $l2m="["; $O2m="]"; } else { $l2m=""; $O2m=""; } return "\"".$l2m.str_replace("\"","\\\"",$O20).$O2m."\""; } function l2n($O2n) { $O2n=str_replace("'","''",$O2n); return $O2n; } function l2o($O2o,$l22) { if (!is_array($l22)) { user_error( "Input parameter $l22 is not an array\n" ,E_USER_ERROR); return; } foreach ($l22 as $l2p) { $O2p=explode($O2o,$l2p); $l2q=count($O2p); if ($l2q == 1) $O2q[$O2p[0]]=NULL; else if ($l2q>1) $O2q[$O2p[0]]=$O2p[1]; } return $O2q; } function l2r($O2c,$O2r) { $l2s=""; $O2s=strrpos($O2c,$O2r); if ($O2s>0) { $l2t=substr($O2c,0,$O2s-1); $O2t=substr($O2c,$O2s-1,1); $l2s=substr($l2t,strrpos($l2t,$O2t)+1); } return $l2s; } function l2u($O20) { return preg_replace("/^_{1}|_{1}\$/","",$O20); }
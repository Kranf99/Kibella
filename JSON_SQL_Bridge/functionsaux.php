<?php use kibella\l2f;
/*
KIBELLA 1.0
Copyright 2016 Frank Vanden berghen
All Right reserved.

Kibella is not a free software. The Kibella software is NOT licensed under the "Apache License". 
If you are interested in distributing, reselling, modifying, contibuting or in general creating 
any derivative work from Kibella, please contact Frank Vanden Berghen at frank@timi.eu.
*/
function O2f($l2g,$O2g=NULL) { if ($O2g === NULL) { echo $l2g; } else { assert($O2g !== FALSE,"The file handle is not false"); fputs($O2g,$l2g); } } function l2h($O2h,$l2i,$O2i=array(),$l2j=0,&$O2j=0) { if (!is_array($O2h)) { user_error( __FUNCTION__.": The first argument should be an array",E_USER_ERROR); return; } if (!is_callable($l2i)) { if (is_array($l2i)) { $l2i=$l2i[0]."::".$l2i[1]; } user_error( __FUNCTION__.": The second argument is not a valid callback ".$l2i,E_USER_ERROR); return; } if (!is_null($O2i) && !is_array($O2i)) { user_error( __FUNCTION__.": The third argument should be an array",E_USER_ERROR); return; } $l2k=count($O2h); if (is_null($O2i)) { $O2i=array(); } $O2k=array(); $O2k[]=NULL; $O2k[]=NULL; $O2k[]=$l2j; $O2k[]=&$O2j; $O2k[]=$l2k; $O2k[]=$O2i; $O2g=NULL; if ($l2k>0) { $l2j=-1; foreach ($O2h as $l2l => $O2l) { $l2j ++; $O2k[0]=$O2l; $O2k[1]=$l2l; $O2k[2]=$l2j; if (is_array($O2l)) { call_user_func_array($l2i,$O2k); $O2j ++; $O2g=l2h($O2l,$l2i,$O2i,$l2j,$O2j); } else { $O2g=call_user_func_array($l2i,$O2k); } } $O2j --; } else { $O2g=call_user_func_array($l2i,$O2k); $O2j --; } return $O2g; } function l2m($O2h) { $O2m=array(); $l2n=array_keys($O2h); sort($l2n); foreach ($l2n as $l2l) { $O2m[$l2l]=$O2h[$l2l]; } return $O2m; } function O2n($O2h,$l2o=FALSE) { return l2h($O2h,"updateDimension",array("max_number_elements" => $l2o)); } function O2o($O2l,$l2l,$l2j,$O2j,$l2k,$l2p) { static $O2p; static $l2q; static $O2q; static $l2r; if ($l2j == 0 && $O2j == 0) { $O2p=1; $l2q=array(array("count" => 0)); $O2q=0; $l2r=FALSE; if (array_key_exists("max_number_elements",$l2p)) $l2r=$l2p["max_number_elements"]; } if ($l2k>0) { $l2q[$O2j]["count"]++; } if (is_array($O2l)) { $l2q[]=array("count" => 0); } else { if ($l2q[$O2j]["count"] == $l2k) { if ($O2j+1>=$O2p) { $O2q=max($O2q,$l2q[$O2j]["count"]); } $O2p=max($O2p,$O2j+1); array_pop($l2q); } } if ($l2r === FALSE) { return max($O2p,$O2j+1); } else { return array(max($O2p,$O2j+1),$O2q); } } function checkdirexistsorcreate($O2r,$l2s=0744,$O2s=TRUE,$l2t=FALSE,$O2t="") { $l29=TRUE; if (!is_dir($O2r)) { if ($l2t) O29("",Ob,$O2t); $l29=mkdir($O2r,$l2s,$O2s); } return $l29; } function l2u($O2u) { if (strlen($O2u)>0) { $O2u=preg_replace("/\\s*,\\s*/",",",$O2u); $l2d=explode(",",strtolower($O2u)); for ($l2v=0; $l2v<count($l2d); $l2v ++) { $l2d[$l2v]=preg_replace("/(^\"(.*)\"\$)|(^\\'(.*)\\'\$)/","\$2\$4",$l2d[$l2v]); } } else { $l2d=array(); } return $l2d; } function deletedir($O2r,$O2v=FALSE,$l2w=0) { if (!is_dir($O2r)) { echo "<pre>ERROR: $O2r must be a directory\nThe deletion process failed.\n</pre>"; return FALSE; } if (substr($O2r,strlen($O2r)-1,1) != "/") { $O2r.="/"; } $O2w=glob($O2r."*",GLOB_MARK); foreach ($O2w as $l2x) { if (is_dir($l2x)) { deletedir($l2x); } else { if ($l2w == 0 || $l2w<0 && (time()-filemtime($l2x))>abs($l2w) || $l2w>0 && filemtime($l2x)<$l2w) { unlink($l2x); } } } if (!$O2v) rmdir($O2r); return TRUE; } function O2x($l2g,$l2y=FALSE) { if ($l2y) { $O2y="["; $l2z="]"; } else { $O2y=""; $l2z=""; } return "\"".$O2y.str_replace("\"","\\\"",$l2g).$l2z."\""; } function O2z($l30) { $l30=str_replace("'","''",$l30); return $l30; } function O30($l31,$O2h) { if (!is_array($O2h)) { user_error( "Input parameter $O2h is not an array\n" ,E_USER_ERROR); return; } foreach ($O2h as $O31) { $l32=explode($l31,$O31); $O32=count($l32); if ($O32 == 1) $l33[$l32[0]]=NULL; else if ($O32>1) $l33[$l32[0]]=$l32[1]; } return $l33; } function O33($O2r,$l34) { $O34=""; $l35=strrpos($O2r,$l34); if ($l35>0) { $O35=substr($O2r,0,$l35-1); $l36=substr($O2r,$l35-1,1); $O34=substr($O35,strrpos($O35,$l36)+1); } return $O34; } function O36($l2g) { return preg_replace("/^_{1}|_{1}\$/","",$l2g); }
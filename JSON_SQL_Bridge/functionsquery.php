<?php
/*
JSON_SQL_Bridge 1.0
Copyright 2016 Frank Vanden berghen
All Right reserved.

JSON_SQL_Bridge is not a free software. The JSON_SQL_Bridge software is NOT licensed under the "Apache License". 
If you are interested in distributing, reselling, modifying, contibuting or in general creating 
any derivative work from JSON_SQL_Bridge, please contact Frank Vanden Berghen at frank@timi.eu.
*/
namespace kibella; function lan($Oan) { return array_sum(array_map( function ($lao) { return $lao->isrunning(); } ,$Oan)); } function Oao($lap) { $O7m=explode("\n",$lap); if (count($O7m)<2) { showmessage( __FILE__ ,"error","The request body of the POST data is not valid. It should have at least 2 elements but ".count($O7m)." were found.\nProgram aborts.\n"); } else { $Oap=floor(count($O7m)/2); echo "{\"responses\":["; $laq=array(); $Oaq=array(); $lar=array(); $Oar=array(); $las=array(); $Oas=-1; $lat=-1; for ($Oat=0; $Oat<$Oap; $Oat ++) { $O7k=json_decode($O7m[2*$Oat],TRUE); $O31=$O7k["index"]; $O7q=$O7m[2*$Oat+1]; $laq[]=l5m($O31,$O7q); l7x($O31,$O7q,lau($laq[$Oat]["responseFiles"]["responseFileFinal"])); if ($laq[$Oat]["cacheFileExists"] === FALSE) { $Oas ++; $las[]=array("type" => "run","index" => $Oas); $Oaq[]=$laq[$Oat]; $Oau=new Ov($laq[$Oat],$Ox=FALSE); $Oar[]=$Oau; } else { $lat ++; $las[]=array("type" => "cache","index" => $lat); $lar[]=$laq[$Oat]; } } if ($Oas>=1 && MULTITHREADING == 1) { foreach ($Oar as $lao) { $lav=$lao->start(PTHREADS_INHERIT_ALL|PTHREADS_ALLOW_GLOBALS); } foreach ($Oar as $lao) { $lao->join(); } for ($Oat=0; $Oat<$Oap; $Oat ++) { if ($Oat>0) echo ","; $Oav=$las[$Oat]["index"]; if ($las[$Oat]["type"] == "run") { assert($Oav<count($Oar),"The index corresponding to the job to retrieve (".$Oav.") is smaller than the number of elements of the aRequestJobsToRun array (".count($Oar).")"); $lao=$Oar[$Oav]; $lav=l7v($lao->l11()); if ($lav === FALSE) showmessage( __FUNCTION__ ,"warning","PARALLEL RUN: The response file could not be read.\nCheck permissions on the file '".$lao->l11()."'.\n"); } else { assert($Oav<count($lar),"The index variable ($Oav) is smaller than the number of elements of the aRequestDetailsFromCache array (".count($lar).")"); $lx=$lar[$Oav]; $lz=Oz($lx); $lav=l7v($lz["responseFile"]); if ($lav === FALSE) showmessage( __FUNCTION__ ,"warning","CACHE READ: The response file could not be read.\nCheck permissions on the file '".$Oy."'.\n"); } } } else { for ($Oat=0; $Oat<$Oap; $Oat ++) { if ($Oat>0) echo ","; $lz=Oz($laq[$Oat]); $lav=l7v($lz["responseFile"]); if ($lav === FALSE) showmessage( __FUNCTION__ ,"warning","SEQUENTIAL RUN: The response file could not be read.\nCheck permissions on the file '".$Oy."'.\n"); } } echo "]}"; } } function l5m($O31,$O7q,$Ox=FALSE) { $O7k=l5w($O31); if ($O7k === FALSE) { if ($Ox) showmessage("",TAG_ERROR,"Table with table ID '$O31' was not found in the registered tables information."); l9f(NULL,0); l37("[]}}"); return FALSE; } $l31=$O7k["table"]; $O30=$O7k["db"]; $lp=$O7k["dbengine"]; $O5v=$O7k["cache"]; $law=l8g($O7q,$l31,$O30); $Oaw=l96($law); $O7r=l7s($O31,$Oaw); if (!l82(O15) && (time()-l82(l15))>l16 && file_exists(l82(O14)) === TRUE) { @unlink(l82(O14)); } $lax=l7t($O7r,$O5v); return array("table" => $l31,"db" => $O30,"dbengine" => $lp,"responseFiles" => $O7r,"parsedQuery" => $law,"cacheEnabled" => $O5v,"cacheFileExists" => $lax); } function Oz($O5l,$Ox=FALSE) { $l31=$O5l["table"]; $O30=$O5l["db"]; $lp=$O5l["dbengine"]; $O7r=$O5l["responseFiles"]; $l59=$O5l["parsedQuery"]; $O5v=$O5l["cacheEnabled"]; $lax=$O5l["cacheFileExists"]; if ($lax === FALSE) { if (file_exists($O7r["responseFileTmp"])) { Oax($O7r["responseFileFinal"]); } else { global $O4s; l7u($l31,$O30,$O4s[$lp],$l59,$O7r["responseFileTmp"]); O7u($O7r,$O5v); if ($Ox) { echo "--------------------\n"; echo "Result from parseEsJsonRequest():\n"; print_r($l59); echo "--------------------\n"; echo "Result from generateEsJsonResponse():\n"; l7v($O7r["responseFileFinal"]); } } } return array("responseFile" => $O7r["responseFileFinal"],"parsedQuery" => $l59); }
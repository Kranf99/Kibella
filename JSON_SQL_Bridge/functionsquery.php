<?php
/*
JSON_SQL_Bridge 1.0
Copyright 2016 Frank Vanden berghen
All Right reserved.

JSON_SQL_Bridge is not a free software. The JSON_SQL_Bridge software is NOT licensed under the "Apache License". 
If you are interested in distributing, reselling, modifying, contibuting or in general creating 
any derivative work from JSON_SQL_Bridge, please contact Frank Vanden Berghen at frank@timi.eu.
*/
namespace kibella; function Oaj($lak) { return array_sum(array_map( function ($Oak) { return $Oak->isrunning(); } ,$lak)); } function lal($Oal) { $l7j=explode("\n",$Oal); if (count($l7j)<2) { showmessage( __FILE__ ,"error","The request body of the POST data is not valid. It should have at least 2 elements but ".count($l7j)." were found.\nProgram aborts.\n"); } else { $lam=floor(count($l7j)/2); echo "{\"responses\":["; $Oam=array(); $lan=array(); $Oan=array(); $lao=array(); $Oao=array(); $lap=-1; $Oap=-1; for ($laq=0; $laq<$lam; $laq ++) { $l7h=json_decode($l7j[2*$laq],TRUE); $l31=$l7h["index"]; $l7n=$l7j[2*$laq+1]; $Oam[]=l5j($l31,$l7n); O7t($l31,$l7n,Oaq($Oam[$laq]["responseFiles"]["responseFileFinal"])); if ($Oam[$laq]["cacheFileExists"] === FALSE) { $lap ++; $Oao[]=array("type" => "run","index" => $lap); $lan[]=$Oam[$laq]; $lar=new lv($Oam[$laq],$lx=FALSE); $lao[]=$lar; } else { $Oap ++; $Oao[]=array("type" => "cache","index" => $Oap); $Oan[]=$Oam[$laq]; } } if ($lap>=1 && MULTITHREADING == 1) { foreach ($lao as $Oak) { $Oar=$Oak->start(PTHREADS_INHERIT_ALL|PTHREADS_ALLOW_GLOBALS); } foreach ($lao as $Oak) { $Oak->join(); } for ($laq=0; $laq<$lam; $laq ++) { if ($laq>0) echo ","; $las=$Oao[$laq]["index"]; if ($Oao[$laq]["type"] == "run") { assert($las<count($lao),"The index corresponding to the job to retrieve (".$las.") is smaller than the number of elements of the aRequestJobsToRun array (".count($lao).")"); $Oak=$lao[$las]; $Oar=O7r($Oak->O10()); if ($Oar === FALSE) showmessage( __FUNCTION__ ,"warning","PARALLEL RUN: The response file could not be read.\nCheck permissions on the file '".$Oak->O10()."'.\n"); } else { assert($las<count($Oan),"The index variable ($las) is smaller than the number of elements of the aRequestDetailsFromCache array (".count($Oan).")"); $Ow=$Oan[$las]; $Oy=lz($Ow); $Oar=O7r($Oy["responseFile"]); if ($Oar === FALSE) showmessage( __FUNCTION__ ,"warning","CACHE READ: The response file could not be read.\nCheck permissions on the file '".$ly."'.\n"); } } } else { for ($laq=0; $laq<$lam; $laq ++) { if ($laq>0) echo ","; $Oy=lz($Oam[$laq]); $Oar=O7r($Oy["responseFile"]); if ($Oar === FALSE) showmessage( __FUNCTION__ ,"warning","SEQUENTIAL RUN: The response file could not be read.\nCheck permissions on the file '".$ly."'.\n"); } } echo "]}"; } } function l5j($l31,$l7n,$lx=FALSE) { $l7h=l5t($l31); if ($l7h === FALSE) { if ($lx) showmessage("",TAG_ERROR,"Table with table ID '$l31' was not found in the registered tables information."); O9b(NULL,0); O36("[]}}"); return FALSE; } $O30=$l7h["table"]; $l30=$l7h["db"]; $lp=$l7h["dbengine"]; $O5s=$l7h["cache"]; $Oas=O8c($l7n,$O30,$l30); $lat=O92($Oas); $l7o=O7o($l31,$lat); if (!O7y(l15) && (time()-O7y(O14))>O15 && file_exists(O7y(l14)) === TRUE) { @unlink(O7y(l14)); } $Oat=O7p($l7o,$O5s); return array("table" => $O30,"db" => $l30,"dbengine" => $lp,"responseFiles" => $l7o,"parsedQuery" => $Oas,"cacheEnabled" => $O5s,"cacheFileExists" => $Oat); } function lz($O5i,$lx=FALSE) { $O30=$O5i["table"]; $l30=$O5i["db"]; $lp=$O5i["dbengine"]; $l7o=$O5i["responseFiles"]; $O55=$O5i["parsedQuery"]; $O5s=$O5i["cacheEnabled"]; $Oat=$O5i["cacheFileExists"]; if ($Oat === FALSE) { if (file_exists($l7o["responseFileTmp"])) { lau($l7o["responseFileFinal"]); } else { global $O4q; O7q($O30,$l30,$O4q[$lp],$O55,$l7o["responseFileTmp"]); l7r($l7o,$O5s); if ($lx) { echo "--------------------\n"; echo "Result from parseEsJsonRequest():\n"; print_r($O55); echo "--------------------\n"; echo "Result from generateEsJsonResponse():\n"; O7r($l7o["responseFileFinal"]); } } } return array("responseFile" => $l7o["responseFileFinal"],"parsedQuery" => $O55); }
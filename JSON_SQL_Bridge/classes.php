<?php
/*
JSON_SQL_Bridge 1.0
Copyright 2016 Frank Vanden berghen
All Right reserved.

JSON_SQL_Bridge is not a free software. The JSON_SQL_Bridge software is NOT licensed under the "Apache License".
If you are interested in distributing, reselling, modifying, contibuting or in general creating
any derivative work from JSON_SQL_Bridge, please contact Frank Vanden Berghen at frank@timi.eu.
*/
namespace kibella; class O8 extends \sqlite3 { function __construct($l9) { try { $this->open($l9); } catch ( \exception $O9) { echo $O9->getmessage().PHP_EOL; showmessage( __FILE__ ,"error","Connection to the SQLite database $l9 could not be established."); } } } class la { private $Oa; function __construct($lb,$Ob="/\t+/") { try { $this->Oa =$this->lc($lb,$Ob); foreach ($this->Oa as $Oc => $ld) { $Od=$this->le($ld); $this->Oa[$Oc]=array("connectionString" => $ld,"dbengine" => $Od["odbc:Driver"],"server" => $Od["Server"],"dbname" => $Od["Database"]); } } catch ( \exception $O9) { echo $O9->getmessage().PHP_EOL; showmessage( __FILE__ ,"warning","The connection to the database has NOT been set."); } } private function lc($Oe,$Ob="/\t+/") { $lf=array(); if (($Of=fopen($Oe,"r")) === FALSE) throw new \exception( __FUNCTION__."Cannot open configuration file ($Oe)."); while (($lg=fgets($Of,02000)) !== FALSE) { $lg=preg_replace("/(^\\s+)|(\\s+\$)/","",$lg); if (preg_match("/^#/",$lg) == 0) { $Og=preg_split($Ob,$lg); if (count($Og)>1) { $lf[$Og[0]]=trim($Og[1]); } } } return $lf; } private function le($ld,$lh=";") { $Oh=preg_split( "/$lh/" ,$ld,-1,PREG_SPLIT_NO_EMPTY); $Od=array(); foreach ($Oh as $Oi) { $lj=strpos($Oi,"="); if ($lj>=0) { $Oj=substr($Oi,0,$lj); $lk=strtolower(substr($Oi,$lj+1)); $lk=preg_replace("/[{}\\s]+/","",$lk); $Od[$Oj]=$lk; } else { showmessage( __FILE__ ,"warning","The currently analyzed database connection string is not properly formed:\n$ld\n"."Caught while analyzing the following part of the connection string: '$Oi'\n"."Check the specified database connections file:\n$lb\n"); } } return $Od; } public function Ok() { return $this->Oa; } public function ll($Oc) { if (array_key_exists($Oc,$this->Oa)) { return $this->Oa[$Oc]["connectionString"]; } return NULL; } public function lm($Oc) { if (array_key_exists($Oc,$this->Oa)) { return $this->Oa[$Oc]["dbengine"]; } return NULL; } public function Om($Oc) { if (array_key_exists($Oc,$this->Oa)) { return $this->Oa[$Oc]["server"]; } return NULL; } public function ln($Oc) { if (array_key_exists($Oc,$this->Oa)) { return $this->Oa[$Oc]["dbname"]; } return NULL; } } class On { public $lo; public $Oo; public $lp; private $Op; private $lq; private $Oq; private $lr=0; function __construct($ls,$lq,$Oo,$lp,$Os) { $this->lo =$ls; $this->lq =$lq; $this->Oo =$Oo; $this->lp =$lp; $this->Oq =lt; try { $this->Op =new \pdo($this->lq ,"","",$Os); } catch ( \pdoexception $O9) { echo $O9->getmessage().PHP_EOL; showmessage( __FILE__ ,"error","The connection to the database could not be established.\n\t\t\t\t\t\t\t\t\t\t\tConnection string: $this->lq"); $this->Op =FALSE; $this->lr =RC_ERROR_NOTFOUND_DB; } } function getdbhandle() { return $this->Op; } function close() { if ($this->Op) { Ot($this->Op ,$this->Oq); } } function lu() { return $this->lr; } } class Ou { private static $Op; public $lo; public $Oo; public $lp; private $lq; private $Os; private $Oq; private $lr=0; function __construct($ls,$lq,$Oo,$lp,$Os) { $this->lo =$ls; $this->lq =$lq; $this->Oo =$Oo; $this->lp =$lp; $this->Os =$Os; $this->Oq =lt; } public function getdbhandle() { if (! isset (self::$Op)) { try { self::$Op=new \pdo($this->lq ,"","",$this->Os); } catch ( \pdoexception $O9) { echo $O9->getmessage().PHP_EOL; showmessage( __FILE__ ,"error","The connection to the database could not be established.\n\t\t\t\t\t\t\t\t\t\t\t\tConnection string: $this->lq"); self::$Op=FALSE; $this->lr =RC_ERROR_NOTFOUND_DB; } } return self::$Op; } function close() { if (self::$Op) { Ot(self::$Op,$this->Oq); } } function lu() { return $this->lr; } } class lv extends \thread { public static $Ov=0; private $lw; private $Ow; private $lx; private $Ox; private $ly; public function __construct($Ow,$lx=FALSE) { self::$Ov=self::$Ov+1; $this->lw =self::$Ov; $this->Ow =$Ow; $this->lx =$lx; $this->Ox =FALSE; } public function run() { $Oy=lz($this->Ow ,$lx=$this->lx); usleep(.1E6); $this->synchronized( function ($ly) { $this->ly =$ly; } ,$Oy["responseFile"]); $this->Ox =TRUE; } public function Oz() { return $this->Ow; } public function l10() { return $this->lx; } public function O10() { return $this->ly; } public function l11() { return $this->Ox; } }
<?php
/*
JSON_SQL_Bridge
Copyright 2016 Frank Vanden berghen
All Right reserved.

JSON_SQL_Bridge is not a free software. The JSON_SQL_Bridge software is NOT licensed under the "Apache License".
If you are interested in distributing, reselling, modifying, contibuting or in general creating
any derivative work from JSON_SQL_Bridge, please contact Frank Vanden Berghen at frank@timi.eu.
*/
namespace kibella; require_once __DIR__."/constants.php"; require_once __DIR__."/functionscfg.php"; require_once __DIR__."/functionsdb.php"; require_once __DIR__."/functionsmsg.php"; require_once __DIR__."/functionsquery.php"; class lk extends \sqlite3 { function __construct($Ok) { try { $this->open($Ok); } catch ( \exception $ll) { echo $ll->getmessage().PHP_EOL; showmessage( __FILE__ ,"error","Connection to the SQLite database $Ok could not be established."); } } } class lm { const Om="provider"; const ln="dsn"; const On="The currently analyzed database connection string is not properly formed."; const lo="The connection string was:"; const Oo="Check the the content of the database connections file being read."; private $lp; function __construct($Op,$lq="/\t+/") { try { $this->lp =Oq($Op,$lq); foreach ($this->lp as $lr => $ls) { $this->lp[$lr]=$this->Os($ls); } } catch ( \exception $ll) { echo $ll->getmessage().PHP_EOL; showmessage( __FILE__ ,"warning","The information on database connections could not be read or could not be set."); } } private function Os($ls,$lt=";") { global $Ot; $lu=preg_split( "/$lt/" ,$ls,2,PREG_SPLIT_NO_EMPTY); if (count($lu)<2) { showmessage( __FILE__ ,"warning",PHP_EOL.self::On.PHP_EOL."At least two elements are expected.".PHP_EOL.self::lo.PHP_EOL."$ls".PHP_EOL.self::Oo.PHP_EOL); return NULL; } $Ou=preg_split("/=/",$lu[0],2,PREG_SPLIT_NO_EMPTY); if (count($lu)<2 && strtolower($Ou[0]) != self::Om) { showmessage( __FILE__ ,"warning",PHP_EOL.self::On.PHP_EOL."The '".self::Om."=' keyword was not found at the beginning of the string.".PHP_EOL.self::lo.PHP_EOL."$ls".PHP_EOL.self::Oo.PHP_EOL); return NULL; } $lv=strtolower($Ou[1]); $Ov=array_keys($Ot); if (in_array($lv,$Ov) === FALSE) { showmessage( __FILE__ ,"warning",PHP_EOL.self::On.PHP_EOL."The provider name is not valid. Valid values are (not case sensitive):".PHP_EOL.implode(" ",$Ov).PHP_EOL.self::lo.PHP_EOL."$ls".PHP_EOL.self::Oo.PHP_EOL); return NULL; } $lw["provider"]=$lv; $Ow=preg_split("/:/",$lu[1],2,PREG_SPLIT_NO_EMPTY); if (count($Ow)<2) { showmessage( __FILE__ ,"warning",PHP_EOL.self::On.PHP_EOL."Expected <driver-type>:<DSN-or-connection-string> as in e.g. odbc:DSN=SQL Server Connection".PHP_EOL.self::lo.PHP_EOL."$ls".PHP_EOL.self::Oo.PHP_EOL); return NULL; } $lw["driver"]=$Ow[0]; $lx=$Ow[1]; $Ox=preg_split( "/$lt/" ,$lx,-1,PREG_SPLIT_NO_EMPTY); if (count($Ox)<1) { showmessage( __FILE__ ,"warning",PHP_EOL.self::On.PHP_EOL."Expected DSN= or a database connection string specific to the driver specified before the ':', namely '".$lw["driver"]."'".PHP_EOL.self::lo.PHP_EOL."$ls".PHP_EOL.self::Oo.PHP_EOL); return NULL; } $ly=array_change_key_case(Oy("=",$Ox),CASE_LOWER); if (array_key_exists(self::ln,$ly)) { $lw["connection_details"]=$ly; } else { $lw["connection_details"]=array("connection_string" => $lx); } return $lw; } public function lz() { return $this->lp; } public function Oz($lr) { if (array_key_exists($lr,$this->lp)) { return $this->lp[$lr]["connection_details"]; } return NULL; } public function l10($lr) { if (array_key_exists($lr,$this->lp)) { return $this->lp[$lr]["provider"]; } return NULL; } public function O10($lr) { if (array_key_exists($lr,$this->lp)) { return $this->lp[$lr]["driver"]; } return NULL; } } class l11 { private static $O11; private static $l12; private $O12; private $l13; public $O13; public $le; private $l14; private $O14; private $l15; private $O15; private $l16; private $O16; private $l17; private $O17=0; function __construct($l13,$l14,$l18,$lx,$O13,$le,$O16) { assert($O13 == O18 && is_string($lx) || $O13 == l19 && is_array($lx),"For embedded databases, the connection details are given as a string and\n"."for client-server databases the connection details are given as an array"); if ($l14 === O19 && $this->l1a($l13)) { $this->l14 =O19; self::$l12=$l13; } else { $this->l14 =O1a; $this->l13 =$l13; } $this->l18 =$l18; $this->O13 =$O13; $this->le =$le; $this->O16 =$O16; $this->l17 =l1b; list($this->l16 ,$this->O14 ,$this->l15 ,$this->O15)=$this->O1b($lx); if ($this->l14 === O1a) { $this->O12 =$this->l1c(); } } private function l1a($l13) { return ! isset (self::$O11) || ( isset (self::$O11) && strtolower(self::$l12) === strtolower($l13)); } private function O1b($lx) { if (is_array($lx)) { if (array_key_exists("dsn",$lx)) { $l16=NULL; $O14=$lx["dsn"]; if (array_key_exists("user",$lx)) { $l15=$lx["user"]; } else { $l15=""; } if (array_key_exists("pwd",$lx)) { $O15=$lx["pwd"]; } else { $O15=""; } } else { $l16=$lx["connection_string"]; $O14=NULL; $l15=NULL; $O15=NULL; } } else { $l16=$lx; $O14=NULL; $l15=NULL; $O15=NULL; } return (array($l16,$O14,$l15,$O15)); } private function l1c() { try { if ($this->O14 != NULL) { $O1c=new \pdo( "$this->l18:$this->O14" ,$this->l15 ,$this->O15 ,$this->O16); } else if ($this->l16 != NULL) { $O1c=new \pdo( "$this->l18:$this->l16" ,"","",$this->O16); } else { new \pdoexception("Incorrect DSN/user/password or connection string"); } } catch ( \pdoexception $ll) { echo $ll->getmessage().PHP_EOL; showmessage( __FILE__ ,"error","The connection to the database could not be established."); $O1c=FALSE; $this->O17 =RC_ERROR_NOTFOUND_DB; } return $O1c; } public function getdbhandle() { if ($this->l14 === O19) { if (! isset (self::$O11)) { self::$O11=$this->l1c(); } return self::$O11; } else if ($this->l14 === O1a) { return $this->O12; } else { showmessage( __FUNCTION__ ,"warning","The type of database handle attribute is invalid ($this->l14)"); return NULL; } } public function l1d() { if ($this->l14 === O19) { return self::$l12; } else if ($this->l14 === O1a) { return $this->l13; } else { showmessage( __FUNCTION__ ,"warning","The type of database handle attribute is invalid ($this->l14)"); return NULL; } } function close() { if ($this->l14 === O19 && self::$O11) { O1d(self::$O11,$this->l17); } else if ($this->l14 === O1a && $this->O12) { return O1d($this->O12 ,$this->l17); } } function l1e() { return $this->O17; } } $O1e=.1e6; if (!class_exists("\\Thread")) { $O1e=0; include ("thread.php"); } class l1f extends \thread { public static $O1f=0; private $l1g; private $O1g; private $l1h; private $O1h; private $l1i; public function __construct($O1g,$l1h=FALSE) { self::$O1f=self::$O1f+1; $this->l1g =self::$O1f; $this->O1g =$O1g; $this->l1h =$l1h; $this->O1h =FALSE; } public function run() { global $O1e; $O1i=l1j($this->O1g ,$l1h=$this->l1h); usleep($O1e); $this->synchronized( function ($l1i) { $this->l1i =$l1i; } ,$O1i["responseFile"]); $this->O1h =TRUE; } public function O1j() { return $this->O1g; } public function l1k() { return $this->l1h; } public function O1k() { return $this->l1i; } public function l1l() { return $this->O1h; } }